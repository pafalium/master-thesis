%!TEX root = ../article.tex

% Introduction
\section{Introduction}
\label{sec:introduction}



%\subsection{From Paper to Bits}
Through the years, computers have been taking more ground in the field of architecture.
In the beginning, they were only used for creating technical drawings using drafting/\gls{cad} software like AutoCAD.
As opposed to drawing by hand, using computers to create these drawings allowed architects to make changes without having to create another copy of the drawing, therefore saving them much time.

%As computers became powerful enough to display 3D graphics, and 3D modeling started to appear, it became possible to model buildings in the computer and get interactive 3D previews of them.
%Having a 3D model of the building and being able to explore it -- to see it from many angles -- is much more intuitive and easier for the architect to think about the building.
%What was only possible to do with a physical model or a perspective drawing, was now faster and more affordable.

\gls{cad} software allows the creation of visualizations and documentation for architectural projects.
However, modeling a building requires several time consuming and repetitive tasks that are not trivial to accomplish using the functionalities that a 3D modeling software provides, such as placing windows/doors in all walls.


%\subsection{Scripting}
The recognition of this problem has led to the emergence of programming languages for 3D modeling software.%
\footnote{These are often called scripting languages.}
By using programming, the architect is able to use a program to describe what he wants to model and let the computer do the modeling task for him.
On top of that, after writing the program, the process of generating and applying changes to the model is much faster than the manual equivalent.
The architect gets to do more in less time.

Some examples of programming languages being used in \gls{cad} software are AutoLisp and Visual Basic for AutoCAD, GDL in ArchiCAD, Python and Grasshopper in Rhinoceros 3D, and Dynamo in Revit.


%\subsection{Generative Design}
Having a faster and more flexible process for building 3D models allows the architect to explore more variations of a design, since it is no longer too expensive and time consuming to remodel.
He can use the program to explore a broader design space.
At first, he can change some of the parameters, but if he wants, he can also change the algorithm.
By making these changes, he can create many different variations of the generated models.
Designing by using programming to generate parts of the design is what is called \gls{gd}.
Furthermore, as stated in \cite{leitao2014pushing}, using \gls{gd} as a new stage of the design process promotes a simpler handling of changes coming from uncertain design intents and emergent requirements (as problem understanding improves or as needs change).
However, in order to create the programs that will generate his designs, the architect needs to have a programming environment that lets him write the programs and see the results.


%\subsection{IDEs for Generative Design}
To create \gls{gd} programs, the architect needs to use a programming language, its runtime environment (like the \gls{cad} where the models are generated), and an \gls{ide}.
The programming language defines what is a program, that is, what concepts can be part of it and how they can be combined to perform tasks that can be understood and executed by a computer.
%For example, it may define a program as a sequence of operations that need to be performed, and define which primitive operations exist, like creating a box or moving an object.
The \gls{ide} provides tools -- editors, compilers, debuggers, among others -- that let the architect create programs.
%The most basic \gls{ide} may have a text editor, where the architect types a textual representation of the program, and an interpreter, that will interpret the program and perform the required operations.

%Most \gls{gd} \glspl{ide} use either data-flow programming or procedural programming.
%The first is often supported by a visual editing environment, while the second is often supported by a textual editing environment.
%Moreover, most \glspl{ide} are aimed at the creation of programs in one specific programming language, like it is the case of Grasshopper 3D\footnote{http://www.grasshopper3d.com/ (last accessed on 10/10/2016)} and Dynamo\footnote{http://dynamobim.com/ (last accessed on 10/10/2016)}.
%There are, however, some \glspl{ide} that can be used to create programs in several programming languages, such as Rosetta\cite{de2012modern}, that supports languages like Racket, Python and AutoLisp.

In order to help architects with the creation of \gls{gd} programs, visual programming \glspl{ide} provide tools that are capable of showing all the nodes/functions that can be added, and the relationship between the code being developed and the results.
They are, therefore, more popular among novices, since they do not require as much training to be used when compared to textual programming \glspl{ide}.
However, as stated in \cite{leitao2012programming}, visual programming languages do not scale well when used in big \gls{gd} projects when compared to textual programming languages.
Textual programming languages have mechanisms that make complexity more manageable, so programs can stay smaller.
Still, textual programming \glspl{ide} lack ways to show the connection between program and results that visual programming \glspl{ide} have.
Some work on this has been done in Rosetta, as shown in \cite{de2012modern}, where it is possible to see which objects each part of the program generated, and the other way around, that is, which parts of the program were responsible for creating an object.

In spite of this, up until now \gls{gd} \glspl{ide} have been primarily desktop applications.
%The next section shows how this affects the architect.
They need to be installed and generally offer limited support when the architect needs to work remotely while still collaborating with his coworkers.

%\subsection{Disadvantages of Desktop Software}
%It is common practice in any creative field to carry a notebook or a sketchbook for the sudden moments of inspiration that appear through the day.
%This way, people make sure that they do not forget any of their ideas.

%A common feature of the tools typically used by architects is that they need to be installed.
%Like so, these are not readily available on every computer.
%As a result, if architects want to be able to work with their software tools, they have to always bring the computer with them.
%This is one of the main reasons why laptop computers are used.
%They combine the ability to run the same applications as desktop computers with transportability.
%People can carry them around and work anywhere.

%Carrying a computer solves the problem of having the tools of trade at hand, but what happens when the architect needs to work with a team?
%There are cloud-based services that he can use to do it.
%He can use services like Skype\footnote{https://www.skype.com (last accessed on 10/10/2016)} when speaking with other people or presenting his work, and he can use file sharing services to build \gls{cad} models collaboratively.
%Still, this is a rudimentary method.
%It does not allow more than one person to edit a file simultaneously, it does not have a system to track versions of files, and it only works on desktop-like computers.%
%\footnote{That run Microsoft Windows, Mac OS or a *nix distribution.}

This is not a problem specific to architects.
In fact, anyone working remotely faces this problem and there are solutions that address it in some fields that also use \gls{cad}.
There are already working cloud-based services that aim to enable this kind of collaboration in these fields.
One example of such services is OnShape\footnote{https://www.onshape.org (last accessed on 10/10/2016)}, that addresses the problem for Product Design/Engineering.
%To do this, OnShape has real-time collaboration, projects are stored in the cloud, has version control, and works both in a web browser and on mobile devices.

What remains to be done is making this functionality available to architects.
%In the next section we describe the goals of this thesis.


\subsection{Goals}
This thesis aims at increasing the architects' productivity when working on \gls{gd} projects by giving them a programming environment in the web specifically for \gls{gd}.
This requires the implementation of a web page, that harnesses the performance and graphical capabilities available in modern web browsers, and a companion application for allowing models to be exported to traditional \gls{cad} applications.

In this way, architects can write their \gls{gd} programs and visualize the results without being chained to a particular computer by using the web page, and can easily integrate results into their normal workflow by using the companion application.


%\subsection{Document Structure}
%The remainder of this document is structured as follows:
%\begin{description}
%  \item[Section \ref{sec:background}] explores related work regarding domain-specific \glspl{ide}, with emphasis on those for 3D modeling. A comparison is also presented to show their similarities and differences.
%  \item[Section \ref{sec:solution}] presents the details of the solution, its components and how they relate to each other. It also explains how the most important features were implemented.
%  \item[Section \ref{sec:evaluation}] evaluates the solution according to the models it can produce and to its performance.
%  \item[Section \ref{sec:conclusion}] concludes the document, presenting the main aspects of each section and presenting some directions to be considered for future work.
%\end{description}
