%!TEX root = ../article.tex

% Introduction
\section{Introduction}
\label{sec:introduction}



%\subsection{From Paper to Bits}
Through the years, computers have been taking more ground in the field of architecture.
In the beginning, they were only used for creating technical drawings using \gls{cad} software but, later, they began to also integrate 3D modeling capabilities.
However, modeling a complex building is still a time-consuming activity that requires several repetitive tasks that are not trivial to accomplish using just the functionalities that a 3D modeling software provides.

%\subsection{Scripting}
The recognition of this problem has led to the emergence of programming languages for 3D modeling software.
By using programming, the architect is able to use a program to describe his design intention and let the computer do the modeling task for him.
On top of that, after writing the program, the process of generating and applying changes to the model is much faster than the manual equivalent.
Like so, the architect gets to do more in less time.

%\subsection{Generative Design}
Having a faster and more flexible process for building 3D models allows the architect to explore more variations of a design, i.e., to explore a broader design space, since it is no longer too expensive and time consuming to remodel.
At first, he can just explore changes to parameters, but, if he wants, he can also change the algorithm.
By making these changes, he can create a large amount of variations of the generated models.
Designing by using programming to generate parts of the design is what is called \gls{gd}.
\gls{gd} allows computers to be used as a new medium for artistic expression\cite{Maeda:2001:DN:559503} that can be used by architects, as shown in \cite{terzidis2003expressive}.
Furthermore, as stated in \cite{leitao2014pushing}, using \gls{gd} as a new stage of the design process promotes a simpler handling of changes coming from uncertain design intents and emergent requirements,as problem understanding improves or as needs change.
However, in order to create the programs that will generate his designs, the architect needs to have a programming environment that lets him write the programs and see their results.


%\subsection{IDEs for Generative Design}
To create \gls{gd} programs, the architect needs to use a programming language, its runtime environment (like the \gls{cad} where the models are generated), and an \gls{ide}.
The programming language defines what is a program, that is, what concepts can be part of it and how they can be combined to perform tasks that can be understood and executed by a computer.
The \gls{ide} provides tools -- editors, compilers, debuggers, among others -- that let the architect create programs.

In order to help architects with the creation of \gls{gd} programs, visual programming \glspl{ide}, such as Grasshopper\footnote{\url{https://www.rhino3d.com/} (last accessed on 10/05/2017)} and Dynamo,\footnote{\url{http://dynamobim.com/} (last accessed on 10/05/2017)} provide tools that are capable of showing all the nodes/functions that can be added, and the relationship between the code being developed and the results.
They are, therefore, more popular among novices, since they do not require as much training to be used when compared to textual programming \glspl{ide}.
However, as stated in \cite{leitao2012programming}, visual programming languages do not scale well when used in big \gls{gd} projects when compared to textual programming languages.
Textual programming languages have mechanisms that make complexity more manageable, so programs can stay smaller.
Still, textual programming \glspl{ide} lack ways to show the connection between program and results that visual programming \glspl{ide} have.
Some work on this has been done in Rosetta, as shown in \cite{Leitao2014illustrated}, where it is possible to see which objects each part of the program generated, and the other way around, that is, which parts of the program were responsible for creating an object.

In spite of this, up until now \gls{gd} \glspl{ide} have been primarily desktop applications, which brings some problems.
Firstly, every computer has its own installation of the \gls{ide}, meaning that users may not be using the most up to date version of the \gls{ide}.
Secondly, desktop applications are more easily pirated, since they run solely on the computer they are installed in.
Moreover, they also generally offer limited support when the architect needs to work remotely while still collaborating with his coworkers.

Web applications are less prone to these problems.
This has led to the creation of many web application counterparts of common desktop applications.
For example, office productivity tools like Microsoft Word, Excel and PowerPoint have seen the appearance of their web application counterparts when Microsoft Office 365 appeared.
Furthermore, complete \gls{cad} web applications have also appeared.
One example is OnShape,\footnote{\url{https://www.onshape.org} (last accessed on 10/05/2017)} a \gls{cad} application for Product Design/Engineering completely accessible from the web browser.

What remains to be done is making this functionality available to architects.


\subsection{Goals}
This thesis aims at increasing the architects' productivity when working on \gls{gd} projects by giving them a programming environment in the web specifically for \gls{gd}.
This requires the implementation of a web application, that harnesses the performance and graphical capabilities available in modern web browsers, and allowing models to be exported to traditional \gls{cad} applications.
