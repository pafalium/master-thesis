%!TEX root = ../article.tex

% Conclusion
\section{Conclusion}
\label{sec:conclusion}


The current trend in architecture practice revolves around using programming as a way to automate repetitive tasks and to explore new design possibilities.
These activities are often put under the umbrella of \acrfull{gd}.

Tools used to support this design approach are mostly desktop applications but this is a leftover from a past that, in many other fields, is already being changed so that applications become web-based.
This change has the significant advantage that applications can be much more easily updated and can be used with whatever machine it is available at that moment.
Moreover, with teams becoming more dispersed geographically, the need arises for using a distributed solution in which team members can still collaborate.
Web applications have the advantage of being platform-independent, requiring only a web browser to be used.

Architects need both 3D modeling and programming capabilities to have an environment where they can do \gls{gd}.
To have a better idea of the features necessary for such environment, Section~\ref{sec:background} explored programming environments for various domains, including \gls{gd}, and also 3D modeling applications.

Firstly, we compared these applications according to their application domain and the purpose they give to programming.
Afterwards, we also compared them according to the editing and the programming paradigm, the persistence and the collaboration support and code editing features.

Following the introduction and comparison of those environments, we described the problem we would address and we proposed our solution in Chapter~\ref{chapter:solution}, which is composed of two components:
(1) a web application, used by the architect to create programs;
and (2) a desktop application that, when run, allows the web application to export results of those programs to \gls{cad} applications.

After defining the architecture, we created a test implementation called Luna Moth.
To help the programming task, Luna Moth runs programs when they change, allows literals to be adjusted by clicking and dragging, and highlights the relationship between program and results in both directions.

In Section~\ref{sec:evaluation}, we presented some examples of programs that were created using the solution.
Additionally, we tested Luna Moth's performance by measuring the program running and export times and comparing them to running times on Rosetta, OpenJSCAD and Grasshopper.
Taking those measurements into consideration, we concluded that running programs in Luna Moth is faster than running these \glspl{ide}.
However, exporting from the web page is slower than running in Rosetta.
We also measured the effect that keeping track of traceability data has on program running times.
As a result, we concluded that collecting traceability data makes programs around 10--50\% slower, which is a great achievement considering that every function call is being recorded.

In conclusion, with Luna Moth, architects are able to explore \gls{gd} without needing to install and update the programming environment and avoiding the installation and use of heavy-weight \gls{cad} applications, which become slow for \gls{gd} exploration.

Due to the achieved performance, we are convinced that web browsers can be seen as serious candidates for the next generations of design tools.
We are also convinced that architects need tools dedicated to \gls{gd} that avoid the complexity of current \gls{cad} applications to enhance the interactivity of the programming environment.

\subsection{Future Work}
Our solution can support the \gls{gd} approach to architecture, however, there are still areas that can be improved.

There is room for improvement in the programming environment.
Some future work includes improving the programming experience by performing static analysis and code completion, supporting addition of illustrations to programs as in \cite{Leitao2014illustrated} and IPython, supporting multiple programming languages, improving the debugging experience, improving the environments traceability, and supporting common modeling primitives.
User testing should also begin to help steer the environment development according to the needs and difficulties of the users and, therefore, make sure it remains both useful and easy to use.

Apart from opportunities in the programming environment, there are also some opportunities for improvement in security and communication between components.
On this side, future work includes sandboxing of user programs, implementation of remote persistence and collaboration, and improvement of the export process's performance.
