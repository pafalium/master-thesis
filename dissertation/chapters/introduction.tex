%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chapter:introduction}

%Motivation
%Goals
%Thesis Outline

\section{From Paper to Bits}
%(paper)
%(drafting: sketchpad, cad mainframes, autocad2d)
%(3d)
%(2d + 3d + analysis + visualization)

Through the years, computers have been taking more ground in the field of architecture.
In the beginning, they were only used for creating technical drawings using drafting/\gls{cad} software like AutoCAD.
As opposed to drawing by hand, using computers to create these drawings allowed architects to make changes without having to create another copy of the drawing, therefore saving them much time.
%Still, most of the finished work, like project documentation and scale models, was left out of the computer.

As computers became powerful enough to display 3D graphics, and 3D modeling started to appear, it became possible to model buildings in the computer and get interactive 3D previews of them.
Having a 3D model of the building and being able to explore it -- to see it from many angles -- is much more intuitive and easier for the architect to think about the building.
What was only possible to do with a physical model or a perspective drawing, was now faster and more affordable.

\gls{cad} software allows the creation of visualizations and documentation for architectural projects.
%There is, however, still a problem: the architect can still find tasks that are mostly a repetitive process which is, again, prone to errors.
However, modeling a building requires several time consuming and repetitive tasks that are not trivial to accomplish using the functionalities that a 3D modeling software provides, such as placing windows/doors in all walls.


\section{Scripting}
The recognition of this problem has led to the emergence of programming languages for 3D modeling software.%
\footnote{These are often called scripting languages.}
By using programming, the architect is able to describe in a program what he wants to model and let the computer do the modeling task for him.
On top of that, after writing the program, the process of generating and applying changes to the model is much faster than the manual equivalent.
The architect gets to do more in less time.

Some examples of programming languages being used in \gls{cad} software are AutoLisp and Visual Basic for AutoCAD, GDL in ArchiCAD, Python and Grasshopper in Rhinoceros 3D, and Dynamo in Revit.


\section{Generative Design}
Having a faster and more flexible process for building 3D models allows the architect to explore more variations of a design, since it is no longer too expensive and time consuming to remodel.
He can use the program to explore a broader design space.
At first, he can change some of the parameters, but if he wants, he can also change the algorithm.
By making these changes, he can create many different variations of the generated models.

Designing by using programming to generate parts of the design is what is called \gls{gd}.

Furthermore, as stated in \cite{leitao2014pushing}, using \gls{gd} as a new stage of the design process promotes a simpler handling of changes coming from uncertain design intents and emergent requirements (as problem understanding improves or as needs change).

%{\bf (variations from Rita Fernandes?)}

However, in order to create the programs that will generate the architect's designs, the architect needs to have a programming environment that lets him write the programs and see the results.


\section{IDEs for Generative Design}
To create \gls{gd} programs, the architect needs to use a programming language, its runtime environment (like the \gls{cad} where the models are generated), and an \gls{ide}.

The programming language defines what is a program, that is, what concepts can be part of it and how they can be combined to perform tasks that can be understood and executed by a computer.
For example, it may define a program as a sequence of operations that need to be performed, and define which primitive operations exist, like creating a box or moving an object.

The \gls{ide} provides tools -- editors, compilers, debuggers, among others -- that let the architect create programs.
The most basic \gls{ide} may have a text editor, where the architect types a textual representation of the program, and an interpreter, that will interpret the program and perform the required operations.

Most \gls{gd} \glspl{ide} use either data-flow programming or procedural programming.
The first is often supported by a visual editing environment, while the second is often supported by a textual editing environment.
%{\bf (ref?)}
Moreover, most \glspl{ide} are aimed at the creation of programs in one specific programming language, like it is the case of Grasshopper 3D\footnote{http://www.grasshopper3d.com/} and Dynamo\footnote{http://dynamobim.com/}.
There are, however, some \glspl{ide} that can be used to create programs in several programming languages, such as Rosetta\cite{de2012modern}, that supports languages like Racket, Python and AutoLisp.

In order to help architects with the creation of \gls{gd} programs, visual programming \glspl{ide} provide tools that are capable of showing all the nodes/functions that can be added, and the relationship between the code being developed and the results.
They are, therefore, more popular among novices, since they do not require as much training to be used when compared to textual programming \glspl{ide}.
However, as stated in \cite{leitao2012programming}, visual programming languages do not scale well when used in big \gls{gd} projects when compared to textual programming languages.
Textual programming languages have mechanisms that make complexity more manageable, so programs can stay smaller.
Still, textual programming \glspl{ide} lack ways to show the connection between program and results that visual programming \glspl{ide} have.
Some work on this has been done in Rosetta, as shown in \cite{de2012modern}, where it is possible to see which objects each part of the program generated, and which parts of the program were responsible for creating an object.

In spite of this, up until now \gls{gd} \glspl{ide} have been primarily desktop applications.
The next section shows how this affects the architect.


\section{Disadvantages of Desktop Software}
It is common practice in any creative field to carry a notebook or a sketchbook for the sudden moments of inspiration that appear through the day.
This way, people make sure that they do not forget any of their ideas.

A common feature of the tools typically used by architects is that they need to be installed.
Like so, these are not readily available on every computer.
As a result, if architects want to be able to work with their software tools, they have to always bring the computer with them.
This is one of the main reasons why laptop computers are used.
They combine the ability to run the same applications as desktop computers with transportability.
People can carry them around and work anywhere.

Carrying a computer solves the problem of having the tools of trade at hand, but what happens when the architect needs to work with a team?
There are cloud-based services that he can use to do it.
He can use services like Skype\footnote{https://www.skype.com} when speaking with other people or presenting his work, and he can use file sharing services to build \gls{cad} models collaboratively.
%(architecture file-sharing examples?)
Still, this is a rudimentary method.
It does not allow more than one person to edit a file simultaneously, it does not have a system to track versions of files, and it only works on desktop-like computers.%
\footnote{That run Microsoft Windows, Mac OS or a *nix distribution.}

This is not a problem specific to architects.
In fact, anyone working remotely faces this problem and there are solutions that address it in some fields that also use \gls{cad}.
There are already working cloud-based services that aim to enable this kind of collaboration in these fields.
One example of such services is OnShape\footnote{https://www.onshape.org}, that addresses the problem for Product Design/Engineering.
To do this, OnShape has real-time collaboration, projects are stored in the cloud, has git-like version control, and works both in a web browser and on mobile devices.

What remains to be done is making this functionality available to architects.
In the next section we describe the goals of this thesis.


\section{Goals}
This thesis aims at increasing the architects' productivity when working on \gls{gd} projects by giving them a programming environment in the web specifically for \gls{gd}.
This required implementing a web page that harnesses the performance and graphical capabilities available in modern web browsers, and implementing a companion application for allowing models to be exported to traditional \gls{cad} applications.

In this way, architects can write their \gls{gd} programs and visualize the results without being chained to a particular computer by using the web page, and can easily integrate results into their normal workflow by using the companion application.


\section{Document Structure}
The remainder of this document is structured as follows:
\begin{description}
  \item[Chapter \ref{chapter:background}] explores related work regarding domain-specific \glspl{ide}, with emphasis on those for 3D modeling. A comparison is also presented to show their similarities and differences.
  \item[Chapter \ref{chapter:solution}] presents the details of the solution, its components and how they relate to each other. It also explains how the most important features were implemented.
  \item[Chapter \ref{chapter:evaluation}] evaluates the solution according to the models it can produce and to its performance.
  \item[Chapter \ref{chapter:conclusion}] --- {\bf Missing }
\end{description}


%Identify the problem clearly.
%- There is a need for a widely available 3d modeling tool for architects?
%- Current 3d modeling tools limit are limited to a computer?

%Thesis
%- A web application is the natural step to architecture software?
%--- It centralizes the information on the Internet making it more accessible and affordable.
%---

%Motivation (Benefits of solving the problem?)
%Goals (What we really want to achieve.)
%Contributions (What we have done that can be used by others.) (Separate "Chapter"?)
%Thesis Outline



%State the requirements. What is there a need for?
%- Higher performance, compared to standard modeling tools.
%- Fit into the current workflow of the architect.




%Introduce the context of the work (the currently used tools, etc).
%Smoothly introduce the problem/need for a solution.
%Lastly, clearly state the goals of the work.

%% Bruno Ferreira, Rosetta Revit BIM
%Apareceram os CADs, (evitam redesenhar tudo à mão)
%Apareceram os BIMs, (modelo computacional de arquitetura)
%Ambos têm muito trabalho repetido
%O Generative Design, Procedural modeling apareceram
%Procedural modeling normalmente limitado a um CAD
%Apareceu o Rosetta
%Rosetta só suporta CADs
%Revit(BIM) tem API
%Vamos usá-la para dar suporte para o Revit ao Rosetta
%
%% Uma secção quando muda de assunto.

%% Projecto de tese
%Programação cada vez mais adoptada
%É preciso aprender muitos conceitos e processos e ter muita disciplina
%Os IDEs juntam todas as ferramentas num pacote
%Os IDEs para software industrial são demasiado para iniciantes
%Há IDEs, feitos para certos domínios, mais amigáveis para iniciantes
%Os arquitetos começaram a usar programação para fazer o seu trabalho e também podem usufruir dos benefícios dos IDEs
%Por exemplo, eles usam os IDEs imbutidos em CADs, o Grasshopper, o Processing e o Rosetta
%Estes IDEs são todos instalados, limitando os computadores onde se pode trabalhar
%Pode-se passar IDE para aplicação web
%Tem de suportar gráficos 3D
%No problem, já existem muitas aplicações web com 3D graças ao WebGL.
%Objectivo: Fazer IDE para arquitetura como uma aplicação web
